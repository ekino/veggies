{
  "version": 3,
  "sources": ["../../../src/core/cast.js"],
  "sourcesContent": ["'use strict'\n\nimport { isFunction, isString, setValue } from '../utils/index.js'\n\n/**\n * @module Cast\n */\n\n/**\n * @name CastFunction\n * @function\n * @param {string} Value to cast\n * @return {*} casted value\n */\n\nconst castFunctions = {}\n\n/**\n * Cast to undefined\n * @return {undefined}\n */\ncastFunctions['undefined'] = () => {\n    return undefined\n}\n\n/**\n * Cast to null\n * @return {null}\n */\ncastFunctions['null'] = () => {\n    return null\n}\n\n/**\n * Cast to number. If is NaN, it throws an error\n * @param {string} value\n * @return {number}\n */\ncastFunctions['number'] = (value) => {\n    const result = Number(value)\n    if (Number.isNaN(result)) {\n        throw new TypeError(`Unable to cast value to number '${value}'`)\n    }\n    return result\n}\n\n/**\n * Cast to a boolean.\n * @param {string} value - true or false\n * @return {boolean} - true if true. False in all other case.\n */\ncastFunctions['boolean'] = (value) => {\n    return value === 'true'\n}\n\n/**\n * Cast to an array\n * @param {string} value - Should follow the pattern \"value1, value2, ...\"\n * @return {Array}\n */\ncastFunctions['array'] = (value) => {\n    return value ? value.replace(/\\s/g, '').split(',').map(getCastedValue) : []\n}\n\n/**\n * Cast to as date\n * @param {string} value - today or a date as string\n * @return {string} - A date json formatted\n */\ncastFunctions['date'] = (value) => {\n    if (value === 'today') {\n        return new Date().toJSON().slice(0, 10)\n    }\n\n    return new Date(value).toJSON()\n}\n\n/**\n * Cast to a string\n * @param {string} value\n * @return {string}\n */\ncastFunctions['string'] = (value) => {\n    return `${value}`\n}\n\n/**\n * Add a new type to cast. This new type can then be used as MyValue((typeName))\n *\n * @example\n * Cast.addType('boolean2', value => value === 'true')\n * //Then it can be used as \"true((boolean2))\"\n *\n * @param {string} typeName - New type name to add. It will be used in the \"(( ))\"\n * @param {CastFunction} castFunction\n */\nexport const addType = (typeName, castFunction) => {\n    if (!isFunction(castFunction))\n        throw new TypeError(\n            `Invalid cast function provided, must be a function (${typeof castFunction})`,\n        )\n    castFunctions[typeName] = castFunction\n}\n\n/**\n * Casts a value according to type directives.\n * Supports the following types:\n * - undefined\n * - null\n * - number\n * - boolean\n * - array\n * - date\n * - string\n *\n * @example\n * Cast.getCastedValue('2((number))')\n * Cast.getCastedValue('true((boolean))')\n * Cast.getCastedValue('((null))')\n * Cast.getCastedValue('raw')\n * // output\n * // > 2\n * // > true\n * // > null\n * // > 'raw'\n *\n * @param {string} value - The value to cast\n * @return {*} The casted value or untouched value if no casting directive found\n */\nexport const getCastedValue = (value) => {\n    if (!isString(value)) return value\n\n    const matchResult = value.match(/^(.*)\\(\\((\\w+)\\)\\)$/)\n\n    if (matchResult) {\n        const type = matchResult[2]\n        const castFunction = castFunctions[type]\n        if (!castFunction) throw new TypeError(`Invalid type provided: ${type} '${value}'`)\n        return castFunction(matchResult[1])\n    }\n\n    return value\n}\n\n/**\n * Casts object all properties.\n *\n * @param {Object} object - The object containing values to cast\n * @return {Object} The object with casted values\n */\nexport const getCastedObject = (object) => {\n    const castedObject = {}\n    Object.keys(object).forEach((key) => {\n        setValue(castedObject, key, getCastedValue(object[key]))\n    })\n\n    return castedObject\n}\n\n/**\n * Casts an array of objects.\n *\n * @example\n * Cast.objects([\n *     { username: 'plouc((string))', is_active: 'true((boolean))', age: '25((number))' },\n *     { username: 'john((string))', is_active: 'false((boolean))', age: '32((number))' },\n * ])\n * // output\n * // > [\n * // >    { username: 'plouc', is_active: true, age: 25 },\n * // >    { username: 'john', is_active: false, age: 32 },\n * // > ]\n *\n * @param {Array.<Object>} objects\n */\nexport const getCastedObjects = (objects) => objects.map((object) => getCastedObject(object))\n\n/**\n * Casts an array of values.\n *\n * @param {Array.<*>} array\n */\nexport const getCastedArray = (array) => array.map((value) => getCastedValue(value))\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA,mBAA+C;AAa/C,MAAM,gBAAgB,CAAC;AAMvB,cAAc,WAAW,IAAI,MAAM;AAC/B,SAAO;AACX;AAMA,cAAc,MAAM,IAAI,MAAM;AAC1B,SAAO;AACX;AAOA,cAAc,QAAQ,IAAI,CAAC,UAAU;AACjC,QAAM,SAAS,OAAO,KAAK;AAC3B,MAAI,OAAO,MAAM,MAAM,GAAG;AACtB,UAAM,IAAI,UAAU,mCAAmC,KAAK,GAAG;AAAA,EACnE;AACA,SAAO;AACX;AAOA,cAAc,SAAS,IAAI,CAAC,UAAU;AAClC,SAAO,UAAU;AACrB;AAOA,cAAc,OAAO,IAAI,CAAC,UAAU;AAChC,SAAO,QAAQ,MAAM,QAAQ,OAAO,EAAE,EAAE,MAAM,GAAG,EAAE,IAAI,cAAc,IAAI,CAAC;AAC9E;AAOA,cAAc,MAAM,IAAI,CAAC,UAAU;AAC/B,MAAI,UAAU,SAAS;AACnB,YAAO,oBAAI,KAAK,GAAE,OAAO,EAAE,MAAM,GAAG,EAAE;AAAA,EAC1C;AAEA,SAAO,IAAI,KAAK,KAAK,EAAE,OAAO;AAClC;AAOA,cAAc,QAAQ,IAAI,CAAC,UAAU;AACjC,SAAO,GAAG,KAAK;AACnB;AAYO,MAAM,UAAU,CAAC,UAAU,iBAAiB;AAC/C,MAAI,KAAC,yBAAW,YAAY;AACxB,UAAM,IAAI;AAAA,MACN,uDAAuD,OAAO,YAAY;AAAA,IAC9E;AACJ,gBAAc,QAAQ,IAAI;AAC9B;AA2BO,MAAM,iBAAiB,CAAC,UAAU;AACrC,MAAI,KAAC,uBAAS,KAAK,EAAG,QAAO;AAE7B,QAAM,cAAc,MAAM,MAAM,qBAAqB;AAErD,MAAI,aAAa;AACb,UAAM,OAAO,YAAY,CAAC;AAC1B,UAAM,eAAe,cAAc,IAAI;AACvC,QAAI,CAAC,aAAc,OAAM,IAAI,UAAU,0BAA0B,IAAI,KAAK,KAAK,GAAG;AAClF,WAAO,aAAa,YAAY,CAAC,CAAC;AAAA,EACtC;AAEA,SAAO;AACX;AAQO,MAAM,kBAAkB,CAAC,WAAW;AACvC,QAAM,eAAe,CAAC;AACtB,SAAO,KAAK,MAAM,EAAE,QAAQ,CAAC,QAAQ;AACjC,+BAAS,cAAc,KAAK,eAAe,OAAO,GAAG,CAAC,CAAC;AAAA,EAC3D,CAAC;AAED,SAAO;AACX;AAkBO,MAAM,mBAAmB,CAAC,YAAY,QAAQ,IAAI,CAAC,WAAW,gBAAgB,MAAM,CAAC;AAOrF,MAAM,iBAAiB,CAAC,UAAU,MAAM,IAAI,CAAC,UAAU,eAAe,KAAK,CAAC;",
  "names": []
}
