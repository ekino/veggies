{
  "version": 3,
  "sources": ["../../../src/core/assertions.js"],
  "sourcesContent": ["'use strict'\n\n/**\n * @module Assertions\n */\n\nimport { expect, use } from 'chai'\nimport moment from 'moment-timezone'\nimport * as Cast from './cast.js'\nimport { registerChaiAssertion } from './custom_chai_assertions.js'\nimport { isEmpty, getValue } from '../utils/index.js'\n\nuse(registerChaiAssertion)\n\nconst negationRegex = `!|! |not |does not |doesn't |is not |isn't `\nconst matchRegex = new RegExp(`^(${negationRegex})?(match|matches|~=)$`)\nconst containRegex = new RegExp(`^(${negationRegex})?(contains?|\\\\*=)$`)\nconst startWithRegex = new RegExp(`^(${negationRegex})?(starts? with|\\\\^=)$`)\nconst endWithRegex = new RegExp(`^(${negationRegex})?(ends? with|\\\\$=)$`)\nconst presentRegex = new RegExp(`^(${negationRegex})?(defined|present|\\\\?)$`)\nconst equalRegex = new RegExp(`^(${negationRegex})?(equals?|=)$`)\nconst typeRegex = new RegExp(`^(${negationRegex})?(type|#=)$`)\nconst relativeDateRegex = new RegExp(`^(${negationRegex})?(equalRelativeDate)$`)\nconst relativeDateValueRegex = /^(\\+?\\d|-?\\d),([A-Za-z]+),([A-Za-z-]{2,5}),(.+)$/\n\nconst RuleName = Object.freeze({\n    Match: Symbol('match'),\n    Contain: Symbol('contain'),\n    StartWith: Symbol('startWith'),\n    EndWith: Symbol('endWith'),\n    Present: Symbol('present'),\n    Equal: Symbol('equal'),\n    Type: Symbol('type'),\n    RelativeDate: Symbol('relativeDate'),\n})\n\n/**\n * Count object properties including nested objects ones.\n * If a property is an object, its key is ignored.\n *\n * @example\n * Assertions.countNestedProperties({\n *     a: true,\n *     b: true,\n *     c: true,\n * })\n * // => 3\n * Assertions.countNestedProperties({\n *     a: true,\n *     b: true,\n *     c: {\n *         a: true,\n *         b: true,\n *     },\n * })\n * // => 4 (c is ignored because it's a nested object)\n *\n * @param {Object} object\n * @return {number}\n */\nexport const countNestedProperties = (object) => {\n    let propertiesCount = 0\n    Object.keys(object).forEach((key) => {\n        if (!isEmpty(object[key]) && typeof object[key] === 'object') {\n            const count = countNestedProperties(object[key])\n            propertiesCount += count\n        } else {\n            propertiesCount++\n        }\n    })\n\n    return propertiesCount\n}\n\n/**\n * @typedef {object} ObjectFieldSpec\n * @property {string} field\n * @property {string} matcher\n * @property {string} value\n */\n\n/**\n * Check that an object matches given specification.\n * specification must be defined as an array of ObjectFieldSpec.\n *\n * @example\n * Assertions.assertObjectMatchSpec(\n *     // object to check\n *     {\n *         first_name: 'Raoul',\n *         last_name: 'Marcel'\n *     },\n *     // spec\n *     [\n *         {\n *             field: 'first_name',\n *             matcher: 'equals',\n *             value: 'Raoul'\n *         },\n *         {\n *             field: 'last_name',\n *             matcher: 'equals',\n *             value: 'Dupond'\n *         },\n *     ]\n * )\n * // Will throw because last_name does not equal 'Dupond'.\n *\n * @see ObjectFieldSpec\n *\n * @param {object}            object        - object to test\n * @param {ObjectFieldSpec[]} spec          - specification\n * @param {boolean}           [exact=false] - if `true`, specification must match all object's properties\n */\nexport const assertObjectMatchSpec = (object, spec, exact = false) => {\n    spec.forEach(({ field, matcher, value }) => {\n        const currentValue = getValue(object, field)\n        const expectedValue = Cast.getCastedValue(value)\n\n        const rule = getMatchingRule(matcher)\n\n        switch (rule.name) {\n            case RuleName.Match: {\n                const baseExpect = expect(\n                    currentValue,\n                    `Property '${field}' (${currentValue}) ${\n                        rule.isNegated ? 'matches' : 'does not match'\n                    } '${expectedValue}'`,\n                )\n                if (rule.isNegated) {\n                    baseExpect.to.not.match(new RegExp(expectedValue))\n                } else {\n                    baseExpect.to.match(new RegExp(expectedValue))\n                }\n                break\n            }\n            case RuleName.Contain: {\n                const baseExpect = expect(\n                    currentValue,\n                    `Property '${field}' (${currentValue}) ${\n                        rule.isNegated ? 'contains' : 'does not contain'\n                    } '${expectedValue}'`,\n                )\n                if (rule.isNegated) {\n                    baseExpect.to.not.contain(expectedValue)\n                } else {\n                    baseExpect.to.contain(expectedValue)\n                }\n                break\n            }\n            case RuleName.StartWith: {\n                const baseExpect = expect(\n                    currentValue,\n                    `Property '${field}' (${currentValue}) ${\n                        rule.isNegated ? 'starts with' : 'does not start with'\n                    } '${expectedValue}'`,\n                )\n                if (rule.isNegated) {\n                    baseExpect.to.not.startWith(expectedValue)\n                } else {\n                    baseExpect.to.startWith(expectedValue)\n                }\n                break\n            }\n            case RuleName.EndWith: {\n                const baseExpect = expect(\n                    currentValue,\n                    `Property '${field}' (${currentValue}) ${\n                        rule.isNegated ? 'ends with' : 'does not end with'\n                    } '${expectedValue}'`,\n                )\n                if (rule.isNegated) {\n                    baseExpect.to.not.endWith(expectedValue)\n                } else {\n                    baseExpect.to.endWith(expectedValue)\n                }\n                break\n            }\n            case RuleName.Present: {\n                const baseExpect = expect(\n                    currentValue,\n                    `Property '${field}' is ${rule.isNegated ? 'defined' : 'undefined'}`,\n                )\n                if (rule.isNegated) {\n                    baseExpect.to.be.undefined\n                } else {\n                    baseExpect.to.not.be.undefined\n                }\n                break\n            }\n            case RuleName.RelativeDate: {\n                const match = relativeDateValueRegex.exec(expectedValue)\n                if (match === null) throw new Error('relative date arguments are invalid')\n                const [, amount, unit, locale, format] = match\n                const normalizedLocale = Intl.getCanonicalLocales(locale)[0]\n                const expectedDate = moment()\n                    .add(amount, unit)\n                    .locale(normalizedLocale)\n                    .format(format)\n                const baseExpect = expect(\n                    currentValue,\n                    `Expected property '${field}' to ${\n                        rule.isNegated ? 'not ' : ''\n                    }equal '${expectedDate}', but found '${currentValue}'`,\n                )\n                if (rule.isNegated) {\n                    baseExpect.to.not.be.deep.equal(expectedDate)\n                } else {\n                    baseExpect.to.be.deep.equal(expectedDate)\n                }\n                break\n            }\n            case RuleName.Type: {\n                const baseExpect = expect(\n                    currentValue,\n                    `Property '${field}' (${currentValue}) type is${\n                        rule.isNegated ? '' : ' not'\n                    } '${expectedValue}'`,\n                )\n                if (rule.isNegated) {\n                    baseExpect.to.not.be.a(expectedValue)\n                } else {\n                    baseExpect.to.be.a(expectedValue)\n                }\n                break\n            }\n            case RuleName.Equal: {\n                const baseExpect = expect(\n                    currentValue,\n                    `Expected property '${field}' to${\n                        rule.isNegated ? ' not' : ''\n                    } equal '${value}', but found '${currentValue}'`,\n                )\n                if (rule.isNegated) {\n                    baseExpect.to.not.be.deep.equal(expectedValue)\n                } else {\n                    baseExpect.to.be.deep.equal(expectedValue)\n                }\n                break\n            }\n        }\n    })\n\n    // We check we have exactly the same number of properties as expected\n    if (exact === true) {\n        const propertiesCount = countNestedProperties(object)\n        expect(\n            propertiesCount,\n            'Expected json response to fully match spec, but it does not',\n        ).to.be.equal(spec.length)\n    }\n}\n\n/**\n * Get a rule matching the given matcher.\n * If it didn't match, it returns undefined.\n *\n * @example\n * Assertions.getMatchingRule(`doesn't match`)\n * // => { name: 'match', isNegated: true }\n * Assertions.getMatchingRule(`contains`)\n * // => { name: 'contain', isNegated: false }\n * Assertions.getMatchingRule(`unknown matcher`)\n * // => undefined\n * @typedef {Object} Rule\n * @property {symbol} name - The name of the rule matched\n * @property {boolean} isNegated - Whether the matcher is negated or not\n * @param {string} matcher\n * @return {Rule} the result of the matching\n */\nexport const getMatchingRule = (matcher) => {\n    const matchGroups = matchRegex.exec(matcher)\n    if (matchGroups) {\n        return { name: RuleName.Match, isNegated: !!matchGroups[1] }\n    }\n\n    const containGroups = containRegex.exec(matcher)\n    if (containGroups) {\n        return { name: RuleName.Contain, isNegated: !!containGroups[1] }\n    }\n\n    const startWithGroups = startWithRegex.exec(matcher)\n    if (startWithGroups) {\n        return { name: RuleName.StartWith, isNegated: !!startWithGroups[1] }\n    }\n\n    const endWithGroups = endWithRegex.exec(matcher)\n    if (endWithGroups) {\n        return { name: RuleName.EndWith, isNegated: !!endWithGroups[1] }\n    }\n\n    const presentGroups = presentRegex.exec(matcher)\n    if (presentGroups) {\n        return { name: RuleName.Present, isNegated: !!presentGroups[1] }\n    }\n\n    const equalGroups = equalRegex.exec(matcher)\n    if (equalGroups) {\n        return { name: RuleName.Equal, isNegated: !!equalGroups[1] }\n    }\n\n    const typeGroups = typeRegex.exec(matcher)\n    if (typeGroups) {\n        return { name: RuleName.Type, isNegated: !!typeGroups[1] }\n    }\n\n    const relativeDateGroups = relativeDateRegex.exec(matcher)\n    if (relativeDateGroups) {\n        return { name: RuleName.RelativeDate, isNegated: !!relativeDateGroups[1] }\n    }\n\n    expect.fail(`Matcher \"${matcher}\" did not match any supported assertions`)\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA,kBAA4B;AAC5B,6BAAmB;AACnB,WAAsB;AACtB,oCAAsC;AACtC,mBAAkC;AAAA,IAElC,iBAAI,mDAAqB;AAEzB,MAAM,gBAAgB;AACtB,MAAM,aAAa,IAAI,OAAO,KAAK,aAAa,uBAAuB;AACvE,MAAM,eAAe,IAAI,OAAO,KAAK,aAAa,qBAAqB;AACvE,MAAM,iBAAiB,IAAI,OAAO,KAAK,aAAa,wBAAwB;AAC5E,MAAM,eAAe,IAAI,OAAO,KAAK,aAAa,sBAAsB;AACxE,MAAM,eAAe,IAAI,OAAO,KAAK,aAAa,0BAA0B;AAC5E,MAAM,aAAa,IAAI,OAAO,KAAK,aAAa,gBAAgB;AAChE,MAAM,YAAY,IAAI,OAAO,KAAK,aAAa,cAAc;AAC7D,MAAM,oBAAoB,IAAI,OAAO,KAAK,aAAa,wBAAwB;AAC/E,MAAM,yBAAyB;AAE/B,MAAM,WAAW,OAAO,OAAO;AAAA,EAC3B,OAAO,OAAO,OAAO;AAAA,EACrB,SAAS,OAAO,SAAS;AAAA,EACzB,WAAW,OAAO,WAAW;AAAA,EAC7B,SAAS,OAAO,SAAS;AAAA,EACzB,SAAS,OAAO,SAAS;AAAA,EACzB,OAAO,OAAO,OAAO;AAAA,EACrB,MAAM,OAAO,MAAM;AAAA,EACnB,cAAc,OAAO,cAAc;AACvC,CAAC;AA0BM,MAAM,wBAAwB,CAAC,WAAW;AAC7C,MAAI,kBAAkB;AACtB,SAAO,KAAK,MAAM,EAAE,QAAQ,CAAC,QAAQ;AACjC,QAAI,KAAC,sBAAQ,OAAO,GAAG,CAAC,KAAK,OAAO,OAAO,GAAG,MAAM,UAAU;AAC1D,YAAM,QAAQ,sBAAsB,OAAO,GAAG,CAAC;AAC/C,yBAAmB;AAAA,IACvB,OAAO;AACH;AAAA,IACJ;AAAA,EACJ,CAAC;AAED,SAAO;AACX;AA0CO,MAAM,wBAAwB,CAAC,QAAQ,MAAM,QAAQ,UAAU;AAClE,OAAK,QAAQ,CAAC,EAAE,OAAO,SAAS,MAAM,MAAM;AACxC,UAAM,mBAAe,uBAAS,QAAQ,KAAK;AAC3C,UAAM,gBAAgB,KAAK,eAAe,KAAK;AAE/C,UAAM,OAAO,gBAAgB,OAAO;AAEpC,YAAQ,KAAK,MAAM;AAAA,MACf,KAAK,SAAS,OAAO;AACjB,cAAM,iBAAa;AAAA,UACf;AAAA,UACA,aAAa,KAAK,MAAM,YAAY,KAChC,KAAK,YAAY,YAAY,gBACjC,KAAK,aAAa;AAAA,QACtB;AACA,YAAI,KAAK,WAAW;AAChB,qBAAW,GAAG,IAAI,MAAM,IAAI,OAAO,aAAa,CAAC;AAAA,QACrD,OAAO;AACH,qBAAW,GAAG,MAAM,IAAI,OAAO,aAAa,CAAC;AAAA,QACjD;AACA;AAAA,MACJ;AAAA,MACA,KAAK,SAAS,SAAS;AACnB,cAAM,iBAAa;AAAA,UACf;AAAA,UACA,aAAa,KAAK,MAAM,YAAY,KAChC,KAAK,YAAY,aAAa,kBAClC,KAAK,aAAa;AAAA,QACtB;AACA,YAAI,KAAK,WAAW;AAChB,qBAAW,GAAG,IAAI,QAAQ,aAAa;AAAA,QAC3C,OAAO;AACH,qBAAW,GAAG,QAAQ,aAAa;AAAA,QACvC;AACA;AAAA,MACJ;AAAA,MACA,KAAK,SAAS,WAAW;AACrB,cAAM,iBAAa;AAAA,UACf;AAAA,UACA,aAAa,KAAK,MAAM,YAAY,KAChC,KAAK,YAAY,gBAAgB,qBACrC,KAAK,aAAa;AAAA,QACtB;AACA,YAAI,KAAK,WAAW;AAChB,qBAAW,GAAG,IAAI,UAAU,aAAa;AAAA,QAC7C,OAAO;AACH,qBAAW,GAAG,UAAU,aAAa;AAAA,QACzC;AACA;AAAA,MACJ;AAAA,MACA,KAAK,SAAS,SAAS;AACnB,cAAM,iBAAa;AAAA,UACf;AAAA,UACA,aAAa,KAAK,MAAM,YAAY,KAChC,KAAK,YAAY,cAAc,mBACnC,KAAK,aAAa;AAAA,QACtB;AACA,YAAI,KAAK,WAAW;AAChB,qBAAW,GAAG,IAAI,QAAQ,aAAa;AAAA,QAC3C,OAAO;AACH,qBAAW,GAAG,QAAQ,aAAa;AAAA,QACvC;AACA;AAAA,MACJ;AAAA,MACA,KAAK,SAAS,SAAS;AACnB,cAAM,iBAAa;AAAA,UACf;AAAA,UACA,aAAa,KAAK,QAAQ,KAAK,YAAY,YAAY,WAAW;AAAA,QACtE;AACA,YAAI,KAAK,WAAW;AAChB,qBAAW,GAAG,GAAG;AAAA,QACrB,OAAO;AACH,qBAAW,GAAG,IAAI,GAAG;AAAA,QACzB;AACA;AAAA,MACJ;AAAA,MACA,KAAK,SAAS,cAAc;AACxB,cAAM,QAAQ,uBAAuB,KAAK,aAAa;AACvD,YAAI,UAAU,KAAM,OAAM,IAAI,MAAM,qCAAqC;AACzE,cAAM,CAAC,EAAE,QAAQ,MAAM,QAAQ,MAAM,IAAI;AACzC,cAAM,mBAAmB,KAAK,oBAAoB,MAAM,EAAE,CAAC;AAC3D,cAAM,mBAAe,uBAAAA,SAAO,EACvB,IAAI,QAAQ,IAAI,EAChB,OAAO,gBAAgB,EACvB,OAAO,MAAM;AAClB,cAAM,iBAAa;AAAA,UACf;AAAA,UACA,sBAAsB,KAAK,QACvB,KAAK,YAAY,SAAS,EAC9B,UAAU,YAAY,iBAAiB,YAAY;AAAA,QACvD;AACA,YAAI,KAAK,WAAW;AAChB,qBAAW,GAAG,IAAI,GAAG,KAAK,MAAM,YAAY;AAAA,QAChD,OAAO;AACH,qBAAW,GAAG,GAAG,KAAK,MAAM,YAAY;AAAA,QAC5C;AACA;AAAA,MACJ;AAAA,MACA,KAAK,SAAS,MAAM;AAChB,cAAM,iBAAa;AAAA,UACf;AAAA,UACA,aAAa,KAAK,MAAM,YAAY,YAChC,KAAK,YAAY,KAAK,MAC1B,KAAK,aAAa;AAAA,QACtB;AACA,YAAI,KAAK,WAAW;AAChB,qBAAW,GAAG,IAAI,GAAG,EAAE,aAAa;AAAA,QACxC,OAAO;AACH,qBAAW,GAAG,GAAG,EAAE,aAAa;AAAA,QACpC;AACA;AAAA,MACJ;AAAA,MACA,KAAK,SAAS,OAAO;AACjB,cAAM,iBAAa;AAAA,UACf;AAAA,UACA,sBAAsB,KAAK,OACvB,KAAK,YAAY,SAAS,EAC9B,WAAW,KAAK,iBAAiB,YAAY;AAAA,QACjD;AACA,YAAI,KAAK,WAAW;AAChB,qBAAW,GAAG,IAAI,GAAG,KAAK,MAAM,aAAa;AAAA,QACjD,OAAO;AACH,qBAAW,GAAG,GAAG,KAAK,MAAM,aAAa;AAAA,QAC7C;AACA;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ,CAAC;AAGD,MAAI,UAAU,MAAM;AAChB,UAAM,kBAAkB,sBAAsB,MAAM;AACpD;AAAA,MACI;AAAA,MACA;AAAA,IACJ,EAAE,GAAG,GAAG,MAAM,KAAK,MAAM;AAAA,EAC7B;AACJ;AAmBO,MAAM,kBAAkB,CAAC,YAAY;AACxC,QAAM,cAAc,WAAW,KAAK,OAAO;AAC3C,MAAI,aAAa;AACb,WAAO,EAAE,MAAM,SAAS,OAAO,WAAW,CAAC,CAAC,YAAY,CAAC,EAAE;AAAA,EAC/D;AAEA,QAAM,gBAAgB,aAAa,KAAK,OAAO;AAC/C,MAAI,eAAe;AACf,WAAO,EAAE,MAAM,SAAS,SAAS,WAAW,CAAC,CAAC,cAAc,CAAC,EAAE;AAAA,EACnE;AAEA,QAAM,kBAAkB,eAAe,KAAK,OAAO;AACnD,MAAI,iBAAiB;AACjB,WAAO,EAAE,MAAM,SAAS,WAAW,WAAW,CAAC,CAAC,gBAAgB,CAAC,EAAE;AAAA,EACvE;AAEA,QAAM,gBAAgB,aAAa,KAAK,OAAO;AAC/C,MAAI,eAAe;AACf,WAAO,EAAE,MAAM,SAAS,SAAS,WAAW,CAAC,CAAC,cAAc,CAAC,EAAE;AAAA,EACnE;AAEA,QAAM,gBAAgB,aAAa,KAAK,OAAO;AAC/C,MAAI,eAAe;AACf,WAAO,EAAE,MAAM,SAAS,SAAS,WAAW,CAAC,CAAC,cAAc,CAAC,EAAE;AAAA,EACnE;AAEA,QAAM,cAAc,WAAW,KAAK,OAAO;AAC3C,MAAI,aAAa;AACb,WAAO,EAAE,MAAM,SAAS,OAAO,WAAW,CAAC,CAAC,YAAY,CAAC,EAAE;AAAA,EAC/D;AAEA,QAAM,aAAa,UAAU,KAAK,OAAO;AACzC,MAAI,YAAY;AACZ,WAAO,EAAE,MAAM,SAAS,MAAM,WAAW,CAAC,CAAC,WAAW,CAAC,EAAE;AAAA,EAC7D;AAEA,QAAM,qBAAqB,kBAAkB,KAAK,OAAO;AACzD,MAAI,oBAAoB;AACpB,WAAO,EAAE,MAAM,SAAS,cAAc,WAAW,CAAC,CAAC,mBAAmB,CAAC,EAAE;AAAA,EAC7E;AAEA,qBAAO,KAAK,YAAY,OAAO,0CAA0C;AAC7E;",
  "names": ["moment"]
}
