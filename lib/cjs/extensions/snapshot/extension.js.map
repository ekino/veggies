{
  "version": 3,
  "sources": ["../../../../src/extensions/snapshot/extension.js"],
  "sourcesContent": ["'use strict'\n\n/**\n * @module extensions/snapshot/Snapshot\n */\n\nimport { format as prettyFormat } from 'pretty-format'\n\nimport * as snapshot from './snapshot.js'\nimport * as clean from './clean.js'\nimport * as statistics from './statistics.js'\nimport * as assertions from '../../core/assertions.js'\nimport { setValue } from '../../utils/index.js'\n\n/**\n * Snapshot extension.\n *\n * @class\n */\nclass Snapshot {\n    /**\n     * @param {Object} options - Options\n     * @param {boolean} [options.updateSnapshots=false] - Should we update the snapshots\n     * @param {boolean} [options.cleanSnapshots=false] - Should we clean the snapshot to remove unused snapshots\n     * @param {boolean} [options.preventSnapshotsCreation=false] - Should we avoid creating missing snapshots\n     */\n    constructor(options) {\n        this.options = options || {}\n        this.shouldUpdate = this.options.updateSnapshots\n        this.cleanSnapshots = this.options.cleanSnapshots\n        this.preventSnapshotsCreation = this.options.preventSnapshotsCreation\n\n        this.featureFile = null\n        this.scenarioLine = -1\n\n        this._snapshotsCount = 0\n    }\n\n    /**\n     * When you do snapshots, it happens that some fields change at each snapshot check (ids, dates ...).\n     * This work the same way as expectToMath but allow you to check some fields in a json objects against a matcher\n     * and ignore them in the snapshot diff replacing them with a generic value.\n     * @param {*} expectedContent - Content to compare to snapshot\n     * @param {ObjectFieldSpec[]} spec  - specification\n     * @throws {string} If snapshot and expected content doesn't match, it throws diff between both\n     */\n    expectToMatchJson(expectedContent, spec) {\n        assertions.assertObjectMatchSpec(expectedContent, spec) // Check optional fields\n\n        const copy = structuredClone(expectedContent)\n        spec.forEach(({ field, matcher, value }) => {\n            // Replace value with generic one\n            setValue(copy, field, `${matcher}(${value})`)\n        })\n\n        this.expectToMatch(copy)\n    }\n\n    /**\n     * Compare a content to it's snapshot.\n     * If no snapshot yet, it create it.\n     *\n     * It uses the context to name the snapshot: feature file, scenario name and nth snapshot of scenario\n     * Snapshot name will be by default stored in FEATURE_FILE_FOLDER_PATH/__snapshots__/FEATURE_FILE_NAME.snap\n     * And snapshot name will be \"SCENARIO_NAME NUMBER_OF_TIME_SCNEARIO_NAME_APPEARD_IN_FEATURE.NUMBER_OF_TIME_WE_SNAPSHOTED_IN_CURRENT_SCENARIO\"\n     * For the first scenario of a scenario called \"Scenario 1\" that only appears once in feature file,\n     * snapshot name will be \"Scenario 1 1.1\"\n     *\n     * If option \"-u\" or \"--updateSnapshots\" is used, all snapshots will be updated\n     * If options \"--cleanSnapshots\" is used, unused stored snapshots will be removed.\n     * @param {*} expectedContent - Content to compare to snapshot\n     * @throws {string} If snapshot and expected content doesn't match, it throws diff between both\n     */\n    expectToMatch(expectedContent) {\n        expectedContent = prettyFormat(expectedContent)\n        expectedContent = snapshot.normalizeNewlines(expectedContent)\n        let snapshotsFile = snapshot.snapshotsPath(this.featureFile, this.options)\n\n        const scenarios = snapshot.extractScenarios(this.featureFile)\n        const snapshotsPrefix = snapshot.prefixSnapshots(scenarios)[this.scenarioLine]\n\n        if (!snapshotsPrefix)\n            throw new Error(\n                `Can not do a snapshot. Scenario not found in file ${this.featureFile} on line ${this.scenarioLine}`,\n            )\n\n        this._snapshotsCount += 1\n        const snapshotName = `${snapshotsPrefix.prefix}.${this._snapshotsCount}`\n        if (this.cleanSnapshots) clean.referenceSnapshot(snapshotsFile, snapshotName) // To clean after all unreferenced snapshots\n\n        const snapshotsContents = snapshot.readSnapshotFile(snapshotsFile)\n        let snapshotContent = snapshotsContents[snapshotName]\n\n        if (this.preventSnapshotsCreation && !snapshotContent)\n            throw new Error(\"The snapshot does not exist and won't be created.\")\n\n        if (!snapshotContent) {\n            statistics.created.push({ file: this.featureFile, name: snapshotName })\n        } else if (this.shouldUpdate) {\n            statistics.updated.push({ file: this.featureFile, name: snapshotName })\n        }\n\n        if (!snapshotContent || this.shouldUpdate) {\n            snapshotsContents[snapshotName] = expectedContent\n            snapshot.writeSnapshotFile(snapshotsFile, snapshotsContents)\n            snapshotContent = expectedContent\n        }\n\n        const diff = snapshot.diff(snapshotContent, expectedContent)\n        if (diff) throw new Error(diff)\n    }\n}\n\n/**\n * Create a new isolated Snapshot module\n * @return {Snapshot}\n */\nexport default function (...args) {\n    return new Snapshot(...args)\n}\n\n/**\n * Snapshot extension.\n * @type {Snapshot}\n */\nexport { Snapshot }\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA,2BAAuC;AAEvC,eAA0B;AAC1B,YAAuB;AACvB,iBAA4B;AAC5B,iBAA4B;AAC5B,mBAAyB;AAOzB,MAAM,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOX,YAAY,SAAS;AACjB,SAAK,UAAU,WAAW,CAAC;AAC3B,SAAK,eAAe,KAAK,QAAQ;AACjC,SAAK,iBAAiB,KAAK,QAAQ;AACnC,SAAK,2BAA2B,KAAK,QAAQ;AAE7C,SAAK,cAAc;AACnB,SAAK,eAAe;AAEpB,SAAK,kBAAkB;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,kBAAkB,iBAAiB,MAAM;AACrC,eAAW,sBAAsB,iBAAiB,IAAI;AAEtD,UAAM,OAAO,gBAAgB,eAAe;AAC5C,SAAK,QAAQ,CAAC,EAAE,OAAO,SAAS,MAAM,MAAM;AAExC,iCAAS,MAAM,OAAO,GAAG,OAAO,IAAI,KAAK,GAAG;AAAA,IAChD,CAAC;AAED,SAAK,cAAc,IAAI;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAiBA,cAAc,iBAAiB;AAC3B,0BAAkB,qBAAAA,QAAa,eAAe;AAC9C,sBAAkB,SAAS,kBAAkB,eAAe;AAC5D,QAAI,gBAAgB,SAAS,cAAc,KAAK,aAAa,KAAK,OAAO;AAEzE,UAAM,YAAY,SAAS,iBAAiB,KAAK,WAAW;AAC5D,UAAM,kBAAkB,SAAS,gBAAgB,SAAS,EAAE,KAAK,YAAY;AAE7E,QAAI,CAAC;AACD,YAAM,IAAI;AAAA,QACN,qDAAqD,KAAK,WAAW,YAAY,KAAK,YAAY;AAAA,MACtG;AAEJ,SAAK,mBAAmB;AACxB,UAAM,eAAe,GAAG,gBAAgB,MAAM,IAAI,KAAK,eAAe;AACtE,QAAI,KAAK,eAAgB,OAAM,kBAAkB,eAAe,YAAY;AAE5E,UAAM,oBAAoB,SAAS,iBAAiB,aAAa;AACjE,QAAI,kBAAkB,kBAAkB,YAAY;AAEpD,QAAI,KAAK,4BAA4B,CAAC;AAClC,YAAM,IAAI,MAAM,mDAAmD;AAEvE,QAAI,CAAC,iBAAiB;AAClB,iBAAW,QAAQ,KAAK,EAAE,MAAM,KAAK,aAAa,MAAM,aAAa,CAAC;AAAA,IAC1E,WAAW,KAAK,cAAc;AAC1B,iBAAW,QAAQ,KAAK,EAAE,MAAM,KAAK,aAAa,MAAM,aAAa,CAAC;AAAA,IAC1E;AAEA,QAAI,CAAC,mBAAmB,KAAK,cAAc;AACvC,wBAAkB,YAAY,IAAI;AAClC,eAAS,kBAAkB,eAAe,iBAAiB;AAC3D,wBAAkB;AAAA,IACtB;AAEA,UAAM,OAAO,SAAS,KAAK,iBAAiB,eAAe;AAC3D,QAAI,KAAM,OAAM,IAAI,MAAM,IAAI;AAAA,EAClC;AACJ;AAMe,SAAR,qBAAqB,MAAM;AAC9B,SAAO,IAAI,SAAS,GAAG,IAAI;AAC/B;",
  "names": ["prettyFormat"]
}
